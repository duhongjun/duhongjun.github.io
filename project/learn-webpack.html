<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webpack原理与实践 | 菜鸡互啄</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/logo.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.301134c6.css" as="style"><link rel="preload" href="/assets/js/app.102dff93.js" as="script"><link rel="preload" href="/assets/js/7.84e4d051.js" as="script"><link rel="preload" href="/assets/js/1.c52b9357.js" as="script"><link rel="preload" href="/assets/js/11.333e4c1b.js" as="script"><link rel="prefetch" href="/assets/js/10.258f5228.js"><link rel="prefetch" href="/assets/js/12.6b136b8d.js"><link rel="prefetch" href="/assets/js/13.0ceb6003.js"><link rel="prefetch" href="/assets/js/14.59eafbbf.js"><link rel="prefetch" href="/assets/js/15.74c13902.js"><link rel="prefetch" href="/assets/js/16.5c8cd82b.js"><link rel="prefetch" href="/assets/js/17.bc01db77.js"><link rel="prefetch" href="/assets/js/18.b74c8dd8.js"><link rel="prefetch" href="/assets/js/19.075d3808.js"><link rel="prefetch" href="/assets/js/20.a012f7f2.js"><link rel="prefetch" href="/assets/js/21.93f4dffc.js"><link rel="prefetch" href="/assets/js/22.b12f186b.js"><link rel="prefetch" href="/assets/js/23.1f3012a3.js"><link rel="prefetch" href="/assets/js/24.5dc7cb9c.js"><link rel="prefetch" href="/assets/js/25.32be55b3.js"><link rel="prefetch" href="/assets/js/26.eedbed54.js"><link rel="prefetch" href="/assets/js/27.812d9cc1.js"><link rel="prefetch" href="/assets/js/28.dbdd419a.js"><link rel="prefetch" href="/assets/js/29.e33ee31f.js"><link rel="prefetch" href="/assets/js/30.9c4fd43a.js"><link rel="prefetch" href="/assets/js/31.6353058b.js"><link rel="prefetch" href="/assets/js/32.ca25b50f.js"><link rel="prefetch" href="/assets/js/33.0b6df38d.js"><link rel="prefetch" href="/assets/js/34.fb5e81a7.js"><link rel="prefetch" href="/assets/js/35.b8aa0e75.js"><link rel="prefetch" href="/assets/js/36.5ef8c43c.js"><link rel="prefetch" href="/assets/js/37.e077e110.js"><link rel="prefetch" href="/assets/js/38.622e3469.js"><link rel="prefetch" href="/assets/js/39.ca3c1a8c.js"><link rel="prefetch" href="/assets/js/4.e3ec3e7f.js"><link rel="prefetch" href="/assets/js/40.a8472019.js"><link rel="prefetch" href="/assets/js/41.6a8fcc74.js"><link rel="prefetch" href="/assets/js/42.fcdf3c13.js"><link rel="prefetch" href="/assets/js/43.82cdd117.js"><link rel="prefetch" href="/assets/js/44.dc4dfda7.js"><link rel="prefetch" href="/assets/js/45.a2b185ce.js"><link rel="prefetch" href="/assets/js/46.e9aeeab1.js"><link rel="prefetch" href="/assets/js/47.712ddb2e.js"><link rel="prefetch" href="/assets/js/5.7adad2e0.js"><link rel="prefetch" href="/assets/js/6.5dda432f.js"><link rel="prefetch" href="/assets/js/8.5aa2fe84.js"><link rel="prefetch" href="/assets/js/9.3f9bfda6.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.eab56a23.js">
    <link rel="stylesheet" href="/assets/css/0.styles.301134c6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpeg" alt="菜鸡互啄" class="logo"> <span class="site-name can-hide">菜鸡互啄</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/timeLine/" class="nav-link">首页</a></div><div class="nav-item"><a href="/technology/" class="nav-link">技术</a></div><div class="nav-item"><a href="/project/" class="nav-link router-link-active">工程化</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签库</a></div><div class="nav-item"><a href="/gossip/" class="nav-link">杂谈</a></div><div class="nav-item"><a href="/message/" class="nav-link">留言板</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duhongjun" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/timeLine/" class="nav-link">首页</a></div><div class="nav-item"><a href="/technology/" class="nav-link">技术</a></div><div class="nav-item"><a href="/project/" class="nav-link router-link-active">工程化</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签库</a></div><div class="nav-item"><a href="/gossip/" class="nav-link">杂谈</a></div><div class="nav-item"><a href="/message/" class="nav-link">留言板</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/duhongjun" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Webpack原理与实践</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/project/learn-webpack.html#webpack背景介绍" class="sidebar-link">Webpack背景介绍</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/project/learn-webpack.html#配置webpack" class="sidebar-link">配置webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#使用loader加载资源" class="sidebar-link">使用Loader加载资源</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#开发loader" class="sidebar-link">开发Loader</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#插件机制" class="sidebar-link">插件机制</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#开发插件" class="sidebar-link">开发插件</a></li></ul></li><li><a href="/project/learn-webpack.html#webpack-运行机制" class="sidebar-link">Webpack 运行机制</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/project/learn-webpack.html#进阶功能" class="sidebar-link">进阶功能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#webpack-dev-server" class="sidebar-link">webpack-dev-server</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#sourcemap最佳实践" class="sidebar-link">SourceMap最佳实践</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#tree-shaking" class="sidebar-link">Tree Shaking</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#sideeffects" class="sidebar-link">sideEffects</a></li><li class="sidebar-sub-header"><a href="/project/learn-webpack.html#code-splitting" class="sidebar-link">Code Splitting</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content__default"><h2 id="webpack背景介绍"><a href="#webpack背景介绍" class="header-anchor">#</a> Webpack背景介绍</h2> <p><strong>Webpack 应该是现代化前端开发的基石，也是目前前端生产力的代名词。</strong></p> <p>说到 Webpack，就不得不提模块化开发，因为 Webpack 最早的出发点就是去实践前端方向的模块化开发。</p> <p>模块化，可以说是当下最重要的前端开发范式之一。<strong>随着前端应用的日益复杂化，我们的项目已经逐渐膨胀到了不得不花大量时间去管理的程度。而模块化就是一种最主流的项目组织方式，它通过把复杂的代码按照功能划分为不同的模块单独维护，从而提高开发效率、降低维护成本。</strong></p> <p>Webpack 本质上仍然还是一个模块化打包工具，它通过“万物皆模块”这种设计思想，巧妙地实现了整个前端项目的模块化。在 Webpack 的理念中，前端项目中的任何资源都可以作为一个模块，任何模块都可以经过 Loader 机制的处理，最终再被打包到一起。</p> <p>Webpack 本身的架构中有两个很核心的特性，分别是 Loader 机制和插件机制。正是因为它的插件机制形成了非常繁荣的生态。</p> <br> <h2 id="配置webpack"><a href="#配置webpack" class="header-anchor">#</a> 配置webpack</h2> <blockquote><p>因为我们编写的webpack配置文件是运行在Node.js环境中， 所以我们可以直接在文件中使用诸如 path 之类的内置模块， 同时因为Node.js使用commonjs规范，所以我们不能在配置文件中使用ES Module写法。</p></blockquote> <p>小技巧： 因为webpack的配置项比较多，很多选项都支持不同类型的配置方式， 所以我们可以使用类型注释的方式借助编辑器(vscode)实现智能提示，使用方式如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 一定记得在运行 Webpack 前先注释掉下面这行，因为Node.js 环境中默认还不支持 import 语句</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Configuration <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'webpack'</span>

<span class="token comment">/**
 * @type {Configuration}
 */</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config

</code></pre></div><h4 id="webpack工作模式"><a href="#webpack工作模式" class="header-anchor">#</a> webpack工作模式</h4> <p>webpack 4 内置了三组预设配置(mode)，如下：</p> <ul><li><p>production （默认值）</p> <p>启动内置优化插件，自动优化打包结果，打包速度偏慢。</p></li> <li><p>devlopment</p> <p>自动优化打包速度，添加一些调试过程中的辅助插件以便于更好的错误调试。</p></li> <li><p>none</p> <p>webpack不做任何优化处理（相较于development和production模式）。</p></li></ul> <h3 id="使用loader加载资源"><a href="#使用loader加载资源" class="header-anchor">#</a> 使用Loader加载资源</h3> <p>webpack使用Loader解析文件。默认的Loader只能解析JS文件(<u>指JS语法， 文件后缀不限，在css文件里写JS也能编译</u>),所以我们加载除了JS文件以外的文件时，需要使用对应的Loader。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'dist.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 配置Loader</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>  <span class="token comment">// 匹配文件名， 使用指定的loader处理匹配到的文件</span>
        <span class="token comment">// use:'css-loader'， // 要使用的loader</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>             <span class="token comment">// 可以多个Loader一起使用， 注意顺序是从后向前</span>
          <span class="token string">'style-loader'</span><span class="token punctuation">,</span>
          <span class="token string">'css-loader'</span>
        <span class="token punctuation">]</span>           
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="通过-js-加载资源模块"><a href="#通过-js-加载资源模块" class="header-anchor">#</a> 通过 JS 加载资源模块</h4> <p>一般 Webpack 打包的入口还是 JavaScript。因为从某种程度上来说，打包入口就是应用的运行入口，而目前前端应用中的业务是由 JS 驱动的，所以更合理的做法还是把 JS 文件作为打包的入口，然后在 JS 代码中通过 import 语句去加载 CSS 文件、图片等其他的文件。</p> <blockquote><p><em>那为什么要在 JS 中加载其他资源？</em></p></blockquote> <p>其实 Webpack 是建议我们在代码中引入当前业务所需要的任意资源文件。因为真正需要这个资源的并不是整个应用，而是你此时正在编写的代码。这就是 Webpack 的设计哲学。</p> <p>如果你遵照 Webpack 的这种设计，所有资源的加载都是由 JS 代码控制，后期也就只需要维护 JS 代码这一条线了。</p> <p>所以说，通过 JavaScript 代码去引入资源文件，或者说是建立 JavaScript 和资源文件的依赖关系，具有明显的优势。因为 JavaScript 代码本身负责完成整个应用的业务功能，放大来说就是驱动了整个前端应用，而 JavaScript 代码在实现业务功能的过程中需要用到样式、图片等资源文件。如果建立这种依赖关系：</p> <ul><li>一来逻辑上比较合理，因为 JS 确实需要这些资源文件配合才能实现整体功能；</li> <li>二来配合 Webpack 这类工具的打包，能确保在上线时，资源不会缺失，而且都是必要的。</li></ul> <h3 id="开发loader"><a href="#开发loader" class="header-anchor">#</a> 开发Loader</h3> <p>假设我们需要开发一个用于加载markdown的Loader, 作用是当我们引入md文件时， 可以直接取得 markdown 转换后的 html 字符串。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// src/about.md</span>
# About
<span class="token keyword">this</span> is a markdown file<span class="token punctuation">.</span>

<span class="token comment">// src/main.js</span>
<span class="token keyword">import</span> about <span class="token keyword">from</span> <span class="token string">'./about.md'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>about<span class="token punctuation">)</span>
<span class="token comment">// 希望 about =&gt; '&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;'</span>

</code></pre></div><p><strong>每个Webpack 的 Loader 都需要导出一个函数，这个函数就是我们这个 Loader 对资源的处理过程，它的输入就是加载到的资源文件内容，输出就是我们加工后的结果。我们通过 source 参数接收输入，通过返回值输出,<u>返回结果必须是一段标准的 JS 代码字符串</u></strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./markdown-loader.js</span>
<span class="token keyword">const</span> marked <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'marked'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token comment">// 1. 将 markdown 转换为 html 字符串</span>
 <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">marked</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
 <span class="token comment">// html =&gt; '&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;'</span>
 <span class="token comment">// 2. 将 html 字符串拼接为一段导出字符串的 JS 代码</span>
 <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">module.exports = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
 <span class="token keyword">return</span> code 
 <span class="token comment">// code =&gt; 'export default &quot;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;&quot;'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们也可以使用多种Loader配合处理的方式,<code>markdown-loader</code>返回处理过后的html字符串，然后使用<code>html-loader</code>继续处理</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./markdown-loader.js</span>
<span class="token keyword">const</span> marked <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'marked'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token parameter">source</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token comment">// 1. 将 markdown 转换为 html 字符串</span>
 <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">marked</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
 <span class="token keyword">return</span> html
<span class="token punctuation">}</span>

<span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
 entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
 output<span class="token operator">:</span> <span class="token punctuation">{</span>
   filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 module<span class="token operator">:</span> <span class="token punctuation">{</span>
   rules<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       test<span class="token operator">:</span> <span class="token regex">/\.md$/</span><span class="token punctuation">,</span>
       use<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token string">'html-loader'</span><span class="token punctuation">,</span>
         <span class="token string">'./markdown-loader'</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此，我们就完成了这个 markdown-loader 模块，其实整个过程重点在于 Loader 的工作原理和实现方式。</p> <h3 id="插件机制"><a href="#插件机制" class="header-anchor">#</a> 插件机制</h3> <p><strong>Webpack 插件机制的目的是为了增强 Webpack 在项目自动化构建方面的能力</strong>。Loader 就是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，所以说 Plugin 的能力范围更广，用途自然也就更多。</p> <p>常见场景：</p> <ul><li>实现自动在打包之前清除 dist 目录（上次的打包结果）；</li> <li>自动生成应用所需要的 HTML 文件；</li> <li>根据不同环境为代码注入类似 API 地址这种可能变化的部分；</li> <li>拷贝不需要参与打包的资源文件到输出目录；</li> <li>压缩 Webpack 打包完成后输出的文件；</li> <li>自动发布打包结果到服务器实现自动部署。</li></ul> <h4 id="使用插件"><a href="#使用插件" class="header-anchor">#</a> 使用插件</h4> <p>我们只需要导入对应的插件， 然后添加到配置对象的<code>plugins</code>中即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token comment">// ./webpack.config.js</span>

<span class="token comment">// 打包前清理dist目录</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
 entry<span class="token operator">:</span> <span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>
 output<span class="token operator">:</span> <span class="token punctuation">{</span>
   filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
   <span class="token comment">// 在plugins里面添加一个插件的实例</span>
   <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="开发插件"><a href="#开发插件" class="header-anchor">#</a> 开发插件</h3> <p>通过前面的介绍，我们知道相比于 Loader，插件的能力范围更宽，因为 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节。</p> <p>Webpack 的插件机制就是我们在软件开发中最常见的钩子机制。</p> <p>具体有哪些预先定义好的钩子，我们可以参考官方文档的 API：</p> <ul><li><a href="https://webpack.js.org/api/compiler-hooks/g" target="_blank" rel="noopener noreferrer">Compiler Hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://webpack.js.org/api/compilation-hooks/" target="_blank" rel="noopener noreferrer">Compilation Hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://webpack.js.org/api/parser/" target="_blank" rel="noopener noreferrer">JavascriptParser Hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <blockquote><p>接下来我们来开发一个清除打包后代码中注释的插件。</p></blockquote> <p><strong>Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个类，在这个类中定义 apply 方法。然后在使用时，再通过这个类来创建一个实例对象去使用这个插件。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin 启动'</span><span class="token punctuation">)</span>
    <span class="token comment">// compiler =&gt; 包含了我们此次构建的所有配置信息</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来， 我们需要明确我们这个任务的执行时机，也就是到底应该把这个任务挂载到哪个钩子上。</p> <p>我们的需求是删除打包后代码中的注释，也就是说只有当 Webpack 需要生成的 bundle.js 文件内容明确过后才可能实施。</p> <p>我们从Compiler Hooks的文档中找到了我们想要的：
<img src="/assets/img/1.0c28ae7e.png" alt="image"></p> <p>通过 <code>compiler</code> 对象的 <code>hooks</code> 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数：</p> <ul><li>第一个是插件的名称，我们这里的插件名称是 RemoveCommentsPlugin；</li> <li>第二个是要挂载到这个钩子上的函数；</li></ul> <p>根据 API 文档中的提示，这里我们在这个函数中接收一个 compilation 对象参数，这个对象可以理解为此次运行打包的上下文，所有打包过程中产生的结果，都会放到这个对象中。</p> <p>接下来使用这个对象中的 assets 属性获取即将写入输出目录的资源文件信息，它是一个对象，我们这里通过 for in 去遍历这个对象， 文件内容需要通过遍历的值对象中的 source 方法获取</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin'</span><span class="token punctuation">,</span> <span class="token parameter">compilation</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">in</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 输出文件内容</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>能够拿到文件内容后，我们回到代码中。这里需要先判断文件名是不是以 .js 结尾，因为 Webpack 打包还有可能输出别的文件，而我们的需求只需要处理 JS 文件。</p> <p>如果是 JS 文件，我们取到文件内容，再通过正则替换的方式移除掉注释，最后覆盖掉 compilation.assets 中对应的对象，在覆盖的对象中，我们同样暴露一个 source 方法用来返回新的内容。另外还需要再暴露一个 size 方法，用来返回内容大小，这是 Webpack 内部要求的格式。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./remove-comments-plugin.js</span>
<span class="token keyword">class</span> <span class="token class-name">RemoveCommentsPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span> <span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>emit<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'RemoveCommentsPlugin'</span><span class="token punctuation">,</span> <span class="token parameter">compilation</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation =&gt; 可以理解为此次打包的上下文</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">in</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> contents <span class="token operator">=</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token keyword">const</span> noComments <span class="token operator">=</span> contents<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\/\*{2,}\/\s?/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
          compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token function-variable function">source</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> noComments<span class="token punctuation">,</span>
            <span class="token function-variable function">size</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> noComments<span class="token punctuation">.</span>length
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总结一下插件机制： <strong><u>Webpack 为每一个工作环节都预留了合适的钩子，我们在扩展时只需要找到合适的时机去做合适的事情就可以了。</u></strong></p> <p>这种钩子机制又叫作<strong>面向切面编程（AOP）</strong>，是软件工程中实现插件机制最常见的方式，如果你在以后的开发工作中有类似的需求，那钩子机制一定是最好的选择。而且对于使用 JavaScript 的开发者而言，实现面向切面编程其实也很容易，很多时候我们都会采用事件机制去实现这种编程模式。</p> <br> <h2 id="webpack-运行机制"><a href="#webpack-运行机制" class="header-anchor">#</a> Webpack 运行机制</h2> <p>Webpack 启动后，会根据配置(entry)，找到指定的入口文件（一般这个文件都会是一个 JS 文件）。
然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树，下面这个动画生动的演示了这个过程：
<img src="/assets/img/2.58d81f65.gif" alt="image"></p> <p>有了这个依赖关系树后， Webpack 会递归遍历这个依赖树，找到每个节点对应的资源文件，
然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打包。</p> <p>整个打包过程中，Loader 机制起了很重要的作用，因为如果没有 Loader 的话，Webpack 就无法实现各种各样类型的资源文件加载。</p> <p>至于插件机制，它并不会影响 Webpack 的核心工作过程，只是 Webpack 为了提供一个强大的扩展能力，它为整个工作过程的每个环节都预制了一个钩子，也就是说我们可以通过插件往 Webpack 工作过程的任意环节植入一些自定义的任务，从而扩展 Webpack 打包功能以外的能力。</p> <br> <h2 id="进阶功能"><a href="#进阶功能" class="header-anchor">#</a> 进阶功能</h2> <h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="header-anchor">#</a> webpack-dev-server</h3> <p><a href="https://github.com/webpack/webpack-dev-server" target="_blank" rel="noopener noreferrer">webpack-dev-server<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是 Webpack 官方推出的一款开发工具，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。</p> <p>webpack-dev-server 是一个独立的 npm 模块， 安装和使用的方法如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 安装</span>
npm install webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token operator">--</span>save<span class="token operator">-</span>dev
<span class="token comment">// 运行</span>
$ npx webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server
</code></pre></div><p>运行 webpack-dev-server 这个命令时，它内部会启动一个 HTTP Server，为打包的结果提供静态文件服务，并且自动使用 Webpack 打包我们的应用，然后监听源代码的变化，一旦文件发生变化，它会立即重新打包。</p> <p>需要注意的是，为了提高工作速率，它并没有将打包结果写入到磁盘中，而是暂时存放在内存中，内部的 HTTP Server 也是从内存中读取这些文件的。这样一来，就会减少很多不必要的磁盘读写操作，大大提高了整体的构建效率。</p> <h4 id="配置选项"><a href="#配置选项" class="header-anchor">#</a> 配置选项</h4> <p>Webpack 配置对象中可以有一个叫作 devServer 的属性，专门用来为 webpack-dev-server 提供配置，具体如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    contentBase<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    compress<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    port<span class="token operator">:</span> <span class="token number">9000</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 详细配置文档：https://webpack.js.org/configuration/dev-server/</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="静态资源访问"><a href="#静态资源访问" class="header-anchor">#</a> 静态资源访问</h4> <p>通过 Webpack 打包输出的文件都可以直接被访问到。但是如果你还有一些没有参与打包的静态文件也需要作为开发服务器的资源被访问，那你就需要额配置。</p> <p>我们通过contentBase 属性指定额外的静态资源路径。这个 contentBase 属性可以是一个字符串或者数组，也就是说你可以配置一个或者多个路径。具体配置如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    contentBase<span class="token operator">:</span> <span class="token string">'public'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="proxy-代理"><a href="#proxy-代理" class="header-anchor">#</a> Proxy 代理</h4> <p>由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。</p> <p>那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生跨域请求问题。</p> <p>可能有人会说，我们可以用跨域资源共享（CORS）解决这个问题。确实如此，如果我们请求的后端 API 支持 CORS，那这个问题就不成立了。但是并不是每种情况下服务端的 API 都支持 CORS。如果前后端应用是同源部署，也就是协议 / 域名 / 端口一致，那这种情况下，根本没必要开启 CORS，所以跨域请求的问题仍然是不可避免的。</p> <p>那解决这种开发阶段跨域请求问题最好的办法，就是在开发服务器中配置一个后端 API 的代理服务，也就是把后端接口服务代理到本地的开发服务地址。</p> <p>webpack-dev-server 就支持直接通过配置的方式，添加代理服务。接下来，我们来看一下它的具体用法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        target<span class="token operator">:</span> <span class="token string">'https://api.github.com'</span><span class="token punctuation">,</span>
        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token string">'^/api'</span><span class="token operator">:</span> <span class="token string">''</span> <span class="token comment">// 替换掉代理地址中的/api =&gt;localhost:8080/api/users =&gt; api.github.com/users</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 确保请求 GitHub 的主机名就是：api.github.com</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><br> <h3 id="sourcemap最佳实践"><a href="#sourcemap最佳实践" class="header-anchor">#</a> SourceMap最佳实践</h3> <p>通过构建或者编译之类的操作，我们将开发阶段编写的源代码转换为能够在生产环境中运行的代码，这种进步同时也意味着实际运行的代码和编写的代码之间存在很大的差异。</p> <p>如果需要调试应用，或是应用运行的过程中出现意料之外的错误，那我们将无从下手。因为无论是调试还是报错，都是基于构建后的代码进行的，我们只能看到错误信息在构建后代码中具体的位置，却很难直接定位到源代码中对应的位置。</p> <p>Source Map（源代码地图）就是解决此类问题最好的办法，它的作用：映射转换后的代码与源代码之间的关系。一段转换后的代码，通过转换过程中生成的 Source Map 文件就可以逆向解析得到对应的源代码。</p> <p>它是一个.map后缀的JSON文件，里面记录的就是转换后和转换前代码之间的映射关系，格式化后可以看到以下几个主要属性:
<img src="/assets/img/3.a02a84d4.png" alt="image"></p> <ul><li>version 是指定所使用的 Source Map 标准版本;</li> <li>sources 中记录的是转换前的源文件名称，因为有可能出现多个文件打包转换为一个文件的情况，所以这里是一个数组；</li> <li>names 是源代码中使用的一些成员名称，我们都知道一般压缩代码时会将我们开发阶段编写的有意义的变量名替换为一些简短的字符，这个属性中记录的就是原始的名称；</li> <li>mappings 属性，这个属性最为关键，它是一个叫作 base64-VLQ 编码的字符串，里面记录的信息就是转换后代码中的字符与转换前代码中的字符之间的映射关系。
<img src="/assets/img/4.999d3016.png" alt="image"></li></ul> <p>一般我们会在转换后的代码中通过添加一行注释的方式来去引入 Source Map 文件。如图：
<img src="/assets/img/5.33080846.png" alt="image"></p> <p>这样如果在 Chrome 浏览器中如果打开了开发人员工具，就会自动请求这个文件，然后根据这个文件的内容逆向解析出来源代码，以便于调试。同时因为有了映射关系，所以代码中如果出现了错误，也就能自动定位找到源代码中的位置了。</p> <h4 id="webpack-中配置-source-map"><a href="#webpack-中配置-source-map" class="header-anchor">#</a> Webpack 中配置 Source Map</h4> <p>Webpack 中的配置属性叫作 devtool， 如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  devtool<span class="token operator">:</span> <span class="token string">'source-map'</span> <span class="token comment">// source map 设置</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Webpack支持的类型有很多种，如下：
<img src="/assets/img/6.79a163fd.png" alt="image"></p> <p>只看一张表可能还是有点蒙，下面就说下具体的区别：</p> <h4 id="eval模式"><a href="#eval模式" class="header-anchor">#</a> eval模式</h4> <p>在去具体了解 Webpack eval 模式的 Source Map 之前，我们需要先了解一下 JavaScript 中 eval 的一些特点。</p> <p>eval 是 JS 中的一个函数，可以将字符串中当做 JavaScript 代码执行。默认情况下会在一个临时的虚拟环境执行， 如图：
<img src="/assets/img/7.2d622f08.png" alt="image">
其实可以通过 sourceURL 来声明这段代码所属文件路径，接下来我们再来尝试在执行的 JS 字符串中添加一个 sourceURL 的声明，具体操作如下：
<img src="/assets/img/8.5e9dc10a.jpg" alt="image"></p> <p>你可以能已经猜到了，eval 模式 其实就是每个模块的代码都被包裹在一个 eval 函数中， 而且最后都使用了 sourceURL 的方式声明这个模块对应的源文件路径，这样浏览器就能知道某一行代码到底是在源代码的哪个文件中。</p> <p>因为在 eval 模式下并不会生成 Source Map 文件，所以它的构建速度最快，但是缺点同样明显：它只能定位源代码的文件路径，无法知道具体的行列信息。</p> <h4 id="eval-source-map"><a href="#eval-source-map" class="header-anchor">#</a> eval-source-map</h4> <p>这个模式也是使用 eval 函数执行模块代码，不过这里有所不同的是，eval-source-map 模式除了定位文件，还可以定位具体的行列信息。相比于 eval 模式，它能够生成 Source Map 文件，可以反推出源代码</p> <h4 id="cheap-eval-source-map"><a href="#cheap-eval-source-map" class="header-anchor">#</a> cheap-eval-source-map</h4> <p>其实就是阉割版的 eval-source-map，因为它虽然也生成了 Source Map 文件，但是这种模式下的 Source Map 只能定位到行，而定位不到列，所以在效果上差了一点点，但是构建速度会提升很多。</p> <h4 id="cheap-module-eval-source-map"><a href="#cheap-module-eval-source-map" class="header-anchor">#</a> cheap-module-eval-source-map</h4> <p>cheap-module-eval-source-map 中定位的源代码与我们编写的源代码是一模一样的，而 cheap-eval-source-map 模式中定位的源代码是经过 ES6 转换后的结果。</p> <p><u>名字中带有 eval 的，代表使用了 eval 执行代码，名字中带有 module 的模式，解析出来的源代码是没有经过 Loader 加工的，有 cheap 表示只能定位源代码的行号。</u></p> <p>还有几个特殊的</p> <ul><li>inline-source-map ——&gt; 跟普通的 source-map 效果相同，只不过这种模式下 Source Map 文件不是以物理文件存在，而是以 data URLs 的方式出现在代码中。</li> <li>hidden-source-map ——&gt; 我们在开发工具中看不到 Source Map 的效果，但是它也确实生成了 Source Map 文件。</li> <li>nosources-source-map ——&gt; 我们能看到错误出现的位置（包含行列位置），但是点进去却看不到源代码。这是为了保护源代码在生产环境中不暴露。</li></ul> <p>开发环境使用 cheap-module-eval-source-map。原因如下：</p> <ul><li>使用框架的情况会比较多，以 React 和 Vue.js 为例，无论是 JSX 还是 vue 单文件组件，Loader 转换后差别都很大，我们需要调试 Loader 转换前的源代码。</li> <li>一般情况下，我们编写的代码每行不会超过 80 个字符，能够定位到行到位置就够了，而且省略列信息还可以提升构建速度。</li> <li>虽然在这种模式下启动打包会比较慢，但大多数时间内使用的 webpack-dev-server 都是在监视模式下重新打包，它重新打包的速度非常快。</li></ul> <p>生产环境的打包，建议选择 nosources-source-map 模式，这样出现错误可以定位到源码位置，也不至于暴露源码。</p> <p>当然这些选择不是绝对的，我们理解这些模式之间的差异的目的，就是为了可以在不同环境中快速选择一个合适的模式，而不是寻求一个通用法则，开发行业也根本不会有绝对的通用法则。</p> <br> <h3 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> Tree Shaking</h3> <p>Tree Shaking 翻译过来的意思就是“摇树”。伴随着摇树的动作，树上的枯树枝和树叶就会掉落下来。</p> <p>我们这里要介绍的 Tree-shaking 也是同样的道理，不过通过 Tree-shaking “摇掉”的是代码中那些没有用到的部分，这部分没有用的代码更专业的说法应该叫作未引用代码（dead-code）。</p> <p>webpack 2以后支持这个特性，我们使用生产模式打包，就会自动开启这个功能。</p> <p>我们不使用 production 模式，一步一步手动开启 Tree-shaking。</p> <p>准备以下两个文件：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// component.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Button</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
  <span class="token comment">// 未引用代码</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dead-code'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 未引用代码</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Link</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./components'</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这里导入的component模块，我们只使用了Button，另一个没有使用，我们使用 none 模式打包，打开打包后的文件：
<img src="/assets/img/9.db4d09f5.jpg" alt="image"></p> <p>我们可以看到，我们并没有使用 Link , 但它仍然被导出模块了。
<img src="/assets/img/10.4d77170b.png" alt="image"></p> <p>很明显这种导出是没意义的，我们可以在 webpack 配置中添加一个 optimization 属性，这个属性用来集中配置 Webpack 内置优化功能， 具体代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块只导出被使用的成员</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>重新打包，打包文件内容如下：
<img src="/assets/img/11.6763bca1.png" alt="image"></p> <p>可以看到，Link不会再被导出了。对于这种未引用代码，如果我们开启压缩代码功能，就可以自动压缩掉这些没有用到的代码。配置如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块只导出被使用的成员</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 压缩输出结果</span>
    minimize<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>重新打包，可以看到 Link 函数已经被自动移除了：
<img src="/assets/img/12.833eda6e.png" alt="image"></p> <p>这就是 Tree-shaking 的实现，整个过程用到了 Webpack 的两个优化功能：</p> <ul><li>usedExports - 打包结果中只导出外部用到的成员；</li> <li>minimize - 压缩打包结果。</li></ul> <p>如果把我们的代码看成一棵大树，那你可以这样理解：</p> <ul><li>usedExports 的作用就是标记树上哪些是枯树枝、枯树叶；</li> <li>minimize 的作用就是负责把枯树枝、枯树叶摇下来。</li></ul> <h4 id="合并模块（扩展）"><a href="#合并模块（扩展）" class="header-anchor">#</a> 合并模块（扩展）</h4> <p>除了 usedExports 选项之外，我们还可以使用一个 concatenateModules 选项继续优化输出。</p> <p>普通打包只是将一个模块最终放入一个单独的函数中，如果模块很多，就意味着在输出结果中会有很多的模块函数。</p> <p>concatenateModules 配置的作用就是尽可能将所有模块合并到一起输出到一个函数中，这样既提升了运行效率，又减少了代码的体积。</p> <p>为了更好的看到效果，我们先关闭 minimize ，修改后的配置文件如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模块只导出被使用的成员</span>
    usedExports<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 尽可能合并每一个模块到一个函数中</span>
    concatenateModules<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 压缩输出结果</span>
    minimize<span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再次打包，打包后生成的文件如下：
<img src="/assets/img/13.e8b6b2a6.png" alt="image"></p> <p>可以看到打包后的文件中就不再是一个模块对应一个函数了，而是把所有的模块都放到了一个函数中。</p> <p>这个特性又被称为 Scope Hoisting，也就是作用域提升，它是 Webpack 3.0 中添加的一个特性。如果再配合 minimize 选项，打包结果的体积又会减小很多。</p> <h4 id="结合-babel-loader-的问题"><a href="#结合-babel-loader-的问题" class="header-anchor">#</a> 结合 babel-loader 的问题</h4> <p>我们需要明确一点：<strong>Tree-shaking 实现的前提是 ES Modules，也就是说：最终交给 Webpack 打包的代码，必须是使用 ES Modules 的方式来组织的模块化。</strong></p> <p>很多时候，我们为了更好的兼容性，会选择使用 babel-loader 去转换我们源代码中的一些 ECMAScript 的新特性。而 Babel 在转换 JS 代码时，很有可能处理掉我们代码中的 ES Modules 部分，把它们转换成 CommonJS 的方式，导致 Tree-shaking 失效。</p> <p>最新版本的 babel-loader(8.x) 并不会导致 Tree-shaking 失效。如果你不确定现在使用的 babel-loader 会不会导致这个问题，最简单的办法就是在配置中将 @babel/preset-env 的 modules 属性设置为 false，确保不会转换 ES Modules，也就确保了 Tree-shaking 的前提。</p> <br> <h3 id="sideeffects"><a href="#sideeffects" class="header-anchor">#</a> sideEffects</h3> <p>Webpack 4 中新增了一个 sideEffects 特性，它允许我们通过配置标识我们的代码是否有副作用，从而提供更大的压缩空间。</p> <blockquote><p>TIPS：模块的副作用指的就是模块执行的时候除了导出成员，是否还做了其他的事情。</p></blockquote> <p><strong>Tree-shaking 只能移除没有用到的代码成员，而想要完整移除没有用到的模块，那就需要开启 sideEffects 特性了。</strong></p> <h4 id="sideeffects的作用"><a href="#sideeffects的作用" class="header-anchor">#</a> sideEffects的作用</h4> <p>我们开启 sideEffects 之后(production模式默认开启)， Webpack 在打包某个模块之前，会先检查这个模块所属的 package.json 中的 sideEffects 标识，以此来判断这个模块是否有副作用，如果没有副作用的话，这些没用到的模块就不再被打包。换句话说，即便这些没有用到的模块中存在一些副作用代码，我们也可以通过 package.json 中的 sideEffects 去强制声明没有副作用。</p> <p>我们来看一个具体的例子，假设我们写了如下的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./src/components/index.js</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./button'</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Link <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./link'</span>
<span class="token comment">// 我们在Button 和 Link 中 都添加一个console(副作用代码)，如下：</span>
<span class="token comment">// ./src/components/button.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Button component~'</span><span class="token punctuation">)</span> <span class="token comment">// 副作用代码</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ./src/components/link.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Link component~'</span><span class="token punctuation">)</span> <span class="token comment">// 副作用代码</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 然后去入口文件引入Button, 代码如下：</span>
<span class="token comment">// ./src/main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./components'</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在设置 usedExports 后， 打包后的结果如下：
<img src="/assets/img/14.64254190.png" alt="image"></p> <p>可以看到 tree-shaking 生效了, 但是因为这些模块中有副作用代码， 导致这些模块并不会被完全移除。我们其实希望的是整个 Link 组件都被优化掉，下面我们尝试一下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他配置项</span>
  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    sideEffects<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// package.json</span>
<span class="token string">&quot;sideEffects&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span>
</code></pre></div><p>再次编译, 可以看到 Link 已经被完全移除了：
<img src="/assets/img/15.5cd8d183.png" alt="image"></p> <p>但是可能我们的项目中确实存在一些有副作用的模块， 比如在JS 中import css 文件， 引入一些polyfill文件等，那我们可以这么配置:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// package.json</span>
  <span class="token string">&quot;sideEffects&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./src/extend.js&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;*.css&quot;</span>
  <span class="token punctuation">]</span>
</code></pre></div><p>这样 webpack 就不会忽略我们配置的这些确实有副作用的模块了。</p> <br> <h3 id="code-splitting"><a href="#code-splitting" class="header-anchor">#</a> Code Splitting</h3> <p>webpack 默认会将所有代码打包到一起，随着代码量的增加，这个包可能会变得非常大。</p> <p>在绝大多数情况下，应用刚开始工作时，并不是所有的模块都是必需的。如果这些模块全部被打包到一起，即便应用只需要一两个模块工作，也必须先把打包后的js文件整体加载进来，而且前端应用一般都是运行在浏览器端，这也就意味着应用的响应速度会受到影响，也会浪费大量的流量和带宽。</p> <p>所以这种 All in One 的方式并不合理，更为合理的方案是<strong>把打包的结果按照一定的规则分离到多个 bundle 中，然后根据应用的运行按需加载</strong>。这样就可以降低启动成本，提高响应速度。</p> <p>Webpack 实现分包的方式主要有两种：</p> <ul><li>根据业务不同配置多个打包入口，输出多个打包结果；</li> <li>结合 ES Modules 的动态导入（Dynamic Imports）特性，按需加载模块。</li></ul> <h4 id="多入口打包"><a href="#多入口打包" class="header-anchor">#</a> 多入口打包</h4> <p>多入口打包主要适用于传统的多页面应用，最常见的划分规则就是一个页面对应一个打包入口，对于不同页面间公用的部分，再提取到公共的结果中。</p> <p>配置起来也非常简单，entry可以接收一个对象，对象里的每个属性都是一个入口，output的名称可以使用[name]占位符。然后使用多个 html-webpack-plugin 为每个入口生成对应的html文件。主要配置如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./webpack.config.js</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    index<span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
    album<span class="token operator">:</span> <span class="token string">'./src/album.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span> <span class="token comment">// [name] 是入口名称</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ... 其他配置</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Multi Entry'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>
      filename<span class="token operator">:</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span>
      chunks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'index'</span><span class="token punctuation">]</span> <span class="token comment">// 指定使用 index.bundle.js,不指定时会把所有的bundle都引入</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Multi Entry'</span><span class="token punctuation">,</span>
      template<span class="token operator">:</span> <span class="token string">'./src/album.html'</span><span class="token punctuation">,</span>
      filename<span class="token operator">:</span> <span class="token string">'album.html'</span><span class="token punctuation">,</span>
      chunks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'album'</span><span class="token punctuation">]</span> <span class="token comment">// 指定使用 album.bundle.js，不指定时会把所有的bundle都引入</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="提取公共模块"><a href="#提取公共模块" class="header-anchor">#</a> 提取公共模块</h4> <p>我们还需要把多个入口公共的模块提取到一个单独的 bundle 中。Webpack 中实现公共模块提取非常简单，我们只需要在优化配置中开启 splitChunks 功能就可以了，具体配置如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>  optimization<span class="token operator">:</span> <span class="token punctuation">{</span>
    splitChunks<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 自动提取所有公共模块到单独 bundle</span>
      chunks<span class="token operator">:</span> <span class="token string">'all'</span>  <span class="token comment">// all表示所有公共模块都可以被提取</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>更多配置参考<a href="https://www.webpackjs.com/plugins/split-chunks-plugin/" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="动态导入"><a href="#动态导入" class="header-anchor">#</a> 动态导入</h4> <p>我们现在更多的是SPA项目，更常见的还是结合 ES Modules 的动态导入特性，从而实现按需加载。</p> <p>Webpack 中支持使用动态导入的方式实现模块的按需加载，而且所有动态导入的模块都会被自动提取到单独的 bundle 中，从而实现分包。实现代码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ./src/index.js</span>
<span class="token comment">// import posts from './posts/posts'</span>
<span class="token comment">// import album from './album/album'</span>
<span class="token keyword">const</span> <span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">||</span> <span class="token string">'#posts'</span>
  <span class="token keyword">const</span> mainElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.main'</span><span class="token punctuation">)</span>
  mainElement<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token string">'#posts'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// mainElement.appendChild(posts())</span>
    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./posts/posts'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> posts <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">posts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token string">'#album'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// mainElement.appendChild(album())</span>
    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./album/album'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> album <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">album</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>总的来说就是为了动态导入模块，可以将 import 关键字作为函数调用。当以这种方式使用时，import 函数返回一个 Promise 对象。这就是 ES Modules 标准中的 Dynamic Imports。</p> <p>以上就是动态导入在 Webpack 中的使用。整个过程我们无需额外配置任何地方，只需要按照 ES Modules 动态导入的方式去导入模块就可以了，Webpack 内部会自动处理分包和按需加载。</p> <p>如果你使用的是 Vue.js 之类的 SPA 开发框架的话，那你项目中路由映射的组件就可以通过这种动态导入的方式实现按需加载，从而实现分包。</p> <h4 id="魔法注释"><a href="#魔法注释" class="header-anchor">#</a> 魔法注释</h4> <p>默认通过动态导入产生的 bundle 文件，它的 name 就是一个序号，如果你需要给这些 bundle 命名的话，就可以使用 Webpack 所特有的魔法注释去实现。具体方式如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 魔法注释  格式如下， 'posts'就是你想起的名字</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: 'posts' */</span><span class="token string">'./posts/posts'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> posts <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    mainElement<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">posts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>除此之外，魔法注释还有个特殊用途：如果你的<strong>chunkName 相同</strong>的话，那<strong>相同的 chunkName 最终就会被打包到一起</strong>。借助这个特点，你就可以根据自己的实际情况，灵活组织动态加载的模块了。</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">6/10/2020, 6:05:30 PM</span></div></div> <!----> </div> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.102dff93.js" defer></script><script src="/assets/js/7.84e4d051.js" defer></script><script src="/assets/js/1.c52b9357.js" defer></script><script src="/assets/js/11.333e4c1b.js" defer></script>
  </body>
</html>
